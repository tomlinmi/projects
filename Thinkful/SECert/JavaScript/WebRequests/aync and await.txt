The async and await keywords
sync keyword transforms the function so that when the function is invoked, the return value will be wrapped in a promise, like this:

const axios = require("axios");
const BASE_URL = "http://localhost:5000";
async function getConstellation(id) {
  //> Placeholder function body
  return true;
}

getConstellation().then(console.log); //> true

await keyword
the await keyword allows you to treat asynchronous requests as if they were synchronous!

async function getConstellationNameById(id) {
  const url = `${BASE_URL}/constellations/${id}`;
  const { data } = await axios.get(url);

  return data.name;
}

getConstellationNameById("n2OEOzp").then(console.log);
//> "Libra"

the object returned by axios has a data key, which you can then immediately use. You can then access it like you would any other object, without having to use then() and catch().

It's important to note that whatever comes after await should be a promise. This means that await will work with class methods like Promise.all().

when you use async and await, you should also use try and catch, like so:
async function getConstellationNameById(id) {
  const url = `${BASE_URL}/constellations/${id}`;
  try {
    const { data } = await axios.get(url);
    return data.name;
  } catch (error) {
    throw `Constellation with id of ${id} could not be found.`;
  }
}
If the GET request fails, the error will be caught, and a new, custom error will be thrown.

And yet, the code above can be used like any other promise, as follows:

getConstellationNameById("n2OEOzp").then(console.log);
//> "Libra"

getConstellationNameById("error").catch(console.log);
//> Constellation with id of error could not be found.
With async and await, you can update your code so that asynchronous code can look more similar to your synchronous code.

Caveats
Using async and await can feel like magic, but it really isn't. Keep in mind the following issues or misconceptions that can arise when using async and await.

Awaiting asynchronous operations on their own
You may assume that, with the await keyword, you can treat all asynchronous calls as if their values were immediately available. But this isn't quite true. Take a look at the following:

async function getConstellationNameById(id) {
  const url = `${BASE_URL}/constellations/${id}`;
  try {
    return await axios.get(url).data.name;
  } catch (error) {
    throw `Constellation with id of ${id} could not be found.`;
  }
}
In the above code, an assumption is made that the code will pause for axios.get(url), and only then will it evaluate data.name. This isn't true, and the operation will fail.

Returning awaited code
Although it won't cause an issue, there is no need to return an awaited response. There is no difference between returning a promise or returning an awaited promise.

async function getConstellationNameById(id) {
  const url = `${BASE_URL}/constellations/${id}`;
  try {
    return await axios.get(url);
  } catch (error) {
    throw `Constellation with id of ${id} could not be found.`;
  }
}
In the above code, regardless of whether or not await is before the axios request, this function will return a promise. In fact, async is also unneeded here.

The async and await keywords are useful when you want to perform additional operations on the values returned from promises. So if you don't care about the return value in a specific function, you don't really need them.



when you use async and await, you should also use try and catch, like so:
*******
async function getConstellationNameById(id) {
  const url = `${BASE_URL}/constellations/${id}`;
  try {
    const { data } = await axios.get(url);
    return data.name;
  } catch (error) {
    throw `Constellation with id of ${id} could not be found.`;
  }
}

And yet, the code above can be used like any other promise, as follows:

getConstellationNameById("n2OEOzp").then(console.log);
//> "Libra"

getConstellationNameById("error").catch(console.log);
//> Constellation with id of error could not be found.